library(dplyr)
library(tibble)
CountsPath<-"./Data/all.otutab_raw.csv"
otuTaxonomyPath<-"./Data/all_taxa.csv"
otutable<-read.csv(CountsPath, sep="\t")
taxatable<-read.csv(otuTaxonomyPath, sep=";")
#get OTU counts and add them to DF
countSum<-apply(otutable[-1],1,sum)
countsDF<-cbind(otutable, countSum)
#Make cumulative percentage to filter out OTUs which make up less than the 5% cummulative sample count
pct<-countSum/sum(countSum)
countsDF<-cbind(countsDF, pct)
countsDF<-countsDF%>%
mutate(cumpct=cumsum(pct))
dim(countsDF)
#bind the taxonomy columns to the otu counts DF
countsWithTaxonomy<-bind_cols(countsDF[order(countsDF$X.OTU.ID),], taxatable[order(taxatable$sequence_identifier),])
#Filter up to 95 % additive abundance
countsWithTaxonomy<-countsWithTaxonomy[countsWithTaxonomy$cumpct < 0.95,]
dim(countsWithTaxonomy)
#delete both columns again
countsWithTaxonomy=select(countsWithTaxonomy,-c(cumpct,pct))
#Make a separate otu table for later analysis
otu_table=select(countsWithTaxonomy,-c(23:30))
otu_table<-column_to_rownames(otu_table, "X.OTU.ID")
otu_table<-as.data.frame(t(otu_table))
#calculate the total number of reads per sample
otu_table$total <- rowSums(otu_table)
otu_table$sponge <- c("Tau","Tau","Tau","Tau","Tau","Tau","Tau","Tme","Tme","Tme","Tme","Tme","Tme","Tme","Tci","Tci","Tci","Tci","Tci","Tci","Tci")
#GET NAMES OF ALL OUTS
otus <- names(otu_table)[-c(2391,2392)]
#PUT SAMPLES BACK AS A ROW
otu_table<-tibble::rownames_to_column(otu_table, "Sample")
int_matrix <- otu_table[,grep('OTU', names(otu_table))]
#Make into zeros and 1s
int_matrix[int_matrix >= 1] <- 1
#how many samples is each otu in
otu_samples <- colSums(int_matrix)
active_otus <- names(otu_samples[otu_samples > 10])
require(igraph)
View(otu_table)
vs <- unique(otu_table$Sample)
g_whole <- graph.empty() + vertices(vs)
for(v in vs){
print(v)
cur_samps <- which(otu_table$Sample == v)
replicates <- otu_table[cur_samps, ]
replicates <- replicates[,grep('OTU', names(replicates))]
#   replicates[replicates >= 1] <- 1
possible_otus <- colSums(replicates)
possible_otus <- names(possible_otus[possible_otus >= 1])
##############
##### comment/uncomment if you are basing OTU selection on the number of samples
##### the are present in (active otus)
possible_otus <- intersect(possible_otus, active_otus)
##############
if(length(possible_otus) == 0){
print(paste('this sponge does not have OTUs:', v))
}
replicates <- replicates[,which(names(replicates) %in% possible_otus)]
##################################################################
####### this bit is for relative abundances
rel_abs <- replicates/rowSums(replicates)
rel_abs <- apply(rel_abs, 2, mean)
##################################################################
###### whereas this is for mean abundances....
abs <- colMeans(replicates)
##################################################################
#   replicates <- replicates[,which(colnames(replicates) %in% possible_otus)]
#   subset <- replicates[subset,]
#   n <- names(subset)
#   n <- names(replicates)
n <- possible_otus
g_whole <- g_whole + vertices(n[!n %in% get.vertex.attribute(g_whole, 'name')])
g_whole[v,n] <- 1
g_whole <- set.edge.attribute(g_whole, 'abs', which(E(g_whole) %in% E(g_whole)[v %--% n]) , as.matrix(abs))
g_whole <- set.edge.attribute(g_whole, 'rel_abs', which(E(g_whole) %in% E(g_whole)[v %--% n]) , as.matrix(rel_abs))
}
otus_in_network <- V(g_whole)$name[! V(g_whole)$name %in% vs]
x <- degree(g_whole, v=otus_in_network)
mean_y <- c()
max_y <- c()
for(v in names(x)){
#print(v)
edges <- neighbors(g_whole, v, mode='in')
abundances <- E(g_whole)[v %--% edges]$rel_abs
mean_y <- append(mean_y, mean(abundances))
max_y <- append(max_y, max(abundances))
}
new_y <- as.vector(log10((mean_y)*100))
plot(x,new_y, xlab='OTU degree', ylab='Log10(Mean relative abundance)')
lo <- smooth.spline(x, new_y) #, control = loess.control(surface = "direct"))
lines(predict(lo), col='green', lwd=2)
linear <- lm(new_y ~ x)
abline(linear, col='blue', lwd=2)
e_edges <- E(g)[from(x)]
e_top_weights <- order(e_edges$weight, decreasing=TRUE)[1:3]
e_edges <- E(graph)[from(x)]
